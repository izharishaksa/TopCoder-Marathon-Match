
import java.io.File;
import java.io.FileOutputStream;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

/**
 *
 * @author izharishaksa
 */
public class PathDefense {

    int SIZE;
    int STEP;
    int CREEP_HEALTH;
    int MONEY;
    boolean[][][] activePaths;
    int[][] board;
    int nBase;
    final int PATH_CODE = 10;
    TowerType[] towerTypes;
    Base[] bases;
    Creep[] creeps;
    List<Tower> placedTowers;

    int[][] dir = new int[][]{{-1, 0}, {0, 1}, {1, 0}, {0, -1}};

    void settingPath(String[] b) {
        board = new int[SIZE][SIZE];
        for (int i = 0; i < SIZE; i++) {
            for (int j = 0; j < SIZE; j++) {
                char c = b[i].charAt(j);
                if (c == '.') {
                    board[i][j] = PATH_CODE;
                }
            }
        }
    }

    void settingBase(String[] b) {
        nBase = 0;
        for (int i = 0; i < SIZE; i++) {
            for (int j = 0; j < SIZE; j++) {
                char c = b[i].charAt(j);
                if (c >= '0' && c <= '9') {
                    nBase++;
                }
            }
        }
        activePaths = new boolean[SIZE][SIZE][nBase];
        bases = new Base[nBase];
        for (int i = 0; i < SIZE; i++) {
            for (int j = 0; j < SIZE; j++) {
                char c = b[i].charAt(j);
                if (c >= '0' && c <= '9') {
                    int id = c - '0';
                    bases[id] = new Base(id, 1000, i, j);
                    LinkedList<Integer> row = new LinkedList<Integer>();
                    LinkedList<Integer> col = new LinkedList<Integer>();
                    row.add(i);
                    col.add(j);
                    activePaths[i][i][id] = true;
                    while (!row.isEmpty()) {
                        int curRow = row.poll();
                        int curCol = col.poll();
                        for (int k = 0; k < 4; k++) {
                            int nextRow = dir[k][0] + curRow;
                            int nextCol = dir[k][1] + curCol;
                            if (nextRow >= 0 && nextRow < SIZE && nextCol >= 0 && nextCol < SIZE
                                    && board[nextRow][nextCol] == PATH_CODE && !activePaths[nextRow][nextCol][id]) {
                                row.add(nextRow);
                                col.add(nextCol);
                                activePaths[nextRow][nextCol][id] = true;
                            }
                        }
                    }
                }
            }
        }
    }

    void settingTowerTypes(String[] b, int[] type) {
        this.towerTypes = new TowerType[type.length / 3];
        int maxRange = 0;
        for (int i = 0; i < towerTypes.length / 3; i++) {
            this.towerTypes[i] = new TowerType(i, type[i * 3], type[i * 3 + 1], type[i * 3 + 2]);
            if (type[i * 3] > maxRange) {
                maxRange = type[i * 3];
            }
        }
    }

    public int init(String[] b, int money, int creepHealth, int creepMoney, int[] towerTypes) {
        debug();
        SIZE = b.length;
        settingPath(b);
        settingBase(b);
        settingTowerTypes(b, towerTypes);
        this.CREEP_HEALTH = creepHealth;
        this.MONEY = money;
        this.creeps = new Creep[2001];
        this.placedTowers = new ArrayList<>();
        return 7;
    }

    int countRange(int a, int b, int c, int d) {
        return ((a - c) * (a - c)) + ((b - d) * (b - d));
    }

    int attack(Tower t) {
        TowerType type = towerTypes[t.type];
        int minRange = type.range * type.range;
        int id = -1;
        for (Creep c : creeps) {
            if (c != null) {
                int cur = countRange(t.row, t.col, c.row, c.col);
                if (cur <= minRange) {
                    minRange = cur;
                    id = c.id;
                }
            }
        }
        if (id != -1) {
            //System.err.println(t.id + "(" + t.row + "," + t.col + ") => " + id + "(" + creeps[id].row + "," + creeps[id].col + ")");
            creeps[id].health -= type.damage;
            if (creeps[id].health < 1) {
                creeps[id] = null;
            }
        }
        return 0;
    }

    public int[] placeTowers(int[] creep, int money, int[] baseHealth) {
        STEP++;
        this.MONEY = money;
        if (creep.length == 0) {
            return new int[0];
        }
        if (STEP % 500 == 0) {
            this.CREEP_HEALTH *= 2;
        }
        //Set the creeps
        for (int i = 0, j = 0; i < creep.length; i += 4) {
            int id = creep[i];
            int health = creep[i + 1];
            int col = creep[i + 2];
            int row = creep[i + 3];
            if (creeps[id] == null) {
                creeps[id] = new Creep(id, row, col, health);
            } else {
                creeps[id].row = row;
                creeps[id].col = col;
                creeps[id].health = health;
                creeps[id].cover = false;
            }
        }

        //Creeps attack the base
        for (Base base : bases) {
            //System.err.println(base.id + " = " + base.row + "," + base.col);
            for (Creep c : creeps) {
                if (c != null) {
                    //System.err.println(c.id + " : "  + c.row + "," + c.col);
                    if (c.row == base.row && c.col == base.col) {
                        System.err.println("masuk sini");
                        bases[base.id].health -= c.health;
                        creeps[c.id] = null;
                    }
                }
            }
        }
        //System.err.println(STEP);
        for (Base base : bases) {
            //System.err.println(base.id + " : " + base.health);
        }

        //Tower attack creeps
        for (Tower t : placedTowers) {
            attack(t);
        }

        List<Integer> list = new ArrayList<>();

        int[] ret = new int[list.size()];
        for (int i = 0; i < ret.length; i++) {
            ret[i] = list.get(i);
        }
        return ret;
    }

    void debug() {
        try {
            PrintStream console = System.err;
            File file = new File("log.txt");
            FileOutputStream fos = new FileOutputStream(file);
            PrintStream ps = new PrintStream(fos);
            System.setErr(ps);
        } catch (Exception e) {
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int money = sc.nextInt();
        sc.nextLine();
        String[] board = new String[N];
        for (int i = 0; i < N; i++) {
            board[i] = sc.nextLine();
        }
        int creepHealth = sc.nextInt();
        int creepMoney = sc.nextInt();
        int NT = sc.nextInt();
        int[] towerTypes = new int[NT];
        for (int i = 0; i < NT; i++) {
            towerTypes[i] = sc.nextInt();
        }
        PathDefense pd = new PathDefense();
        pd.init(board, money, creepHealth, creepMoney, towerTypes);
        for (int i = 0; i < 2000; i++) {
            money = sc.nextInt();
            int NC = sc.nextInt();
            int[] creep = new int[NC];
            for (int j = 0; j < creep.length; j++) {
                creep[j] = sc.nextInt();
            }
            int B = sc.nextInt();
            int[] baseHealth = new int[B];
            for (int j = 0; j < baseHealth.length; j++) {
                baseHealth[j] = sc.nextInt();
            }
            int[] ret = pd.placeTowers(creep, money, baseHealth);
            System.out.println(ret.length);
            for (int res : ret) {
                System.out.println(res);
            }
            System.out.flush();
        }
    }

}

class Base {

    int id, health, row, col;

    public Base(int id, int health, int row, int col) {
        this.id = id;
        this.health = health;
        this.row = row;
        this.col = col;
    }
}

class Creep {

    int id, row, col, health;
    boolean cover;

    public Creep(int id, int row, int col, int health) {
        this.id = id;
        this.row = row;
        this.col = col;
        this.health = health;
    }

}

class TowerType {

    int id, range, damage, cost;

    public TowerType(int id, int range, int damage, int cost) {
        this.id = id;
        this.range = range;
        this.damage = damage;
        this.cost = cost;
    }
}

class Tower implements Comparable<Tower> {

    int id, type, row, col, score, dist, aCreep;

    public Tower(int id, int type, int row, int col) {
        this.id = id;
        this.type = type;
        this.row = row;
        this.col = col;
    }

    @Override
    public int compareTo(Tower o) {
        return o.score - score;
    }

    @Override
    public String toString() {
        return id + " => " + row + "," + col + " : " + type + " score = " + score;
    }
}
